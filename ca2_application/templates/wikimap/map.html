{% extends 'base.html' %}
{% load static %}

{% block title %}WikiMap - Explore{% endblock %}
{% block main_classes %}flex-grow w-full pt-16{% endblock %}

{% block extra_head %}
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <!-- Leaflet MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    
    <style>
        /* Ensure map takes full available height */
        #map-container {
            height: calc(100vh - 4rem - env(safe-area-inset-top));
            width: 100%;
            z-index: 0;
            background-color: #f8fafc; /* Light elegant background for map container */
        }

        /* Marker Cluster Animations & Styles */
        .custom-cluster-icon {
            /* No transition on the wrapper to prevent positioning glitches (floating markers) */
        }
        .custom-cluster-icon:hover {
            z-index: 1000 !important;
        }

        /* Safe transitions for individual markers */
        .marker-transition {
            transition-property: fill, stroke, r;
            transition-duration: 0.3s;
            transition-timing-function: ease-out;
        }

        .cluster-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: white;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            font-weight: 700;
            box-shadow: 
                0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                0 2px 4px -1px rgba(0, 0, 0, 0.06),
                inset 0 1px 1px rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            backdrop-filter: blur(4px);
        }

        .cluster-small {
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%); /* Blue-400 to Blue-500 */
        }
        .cluster-medium {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); /* Blue-500 to Blue-600 */
        }
        .cluster-large {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%); /* Blue-600 to Blue-700 */
        }
        .cluster-huge {
            background: linear-gradient(135deg, #1d4ed8 0%, #1e40af 100%); /* Blue-700 to Blue-800 */
        }
    </style>
{% endblock %}

{% block content %}
    <div id="map-root" class="w-full h-full relative"></div>
{% endblock %}

{% block extra_scripts %}
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- Leaflet MarkerCluster JS -->
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>

    <script type="text/babel">
        // Timeline Control Component
        const TimelineControl = ({ minDate, maxDate, currentRange, onChange }) => {
            const [localRange, setLocalRange] = React.useState(currentRange);

            const handleMinChange = (e) => {
                const newVal = parseInt(e.target.value);
                if (newVal < localRange[1]) {
                    setLocalRange([newVal, localRange[1]]);
                    onChange([newVal, localRange[1]]);
                }
            };

            const handleMaxChange = (e) => {
                const newVal = parseInt(e.target.value);
                if (newVal > localRange[0]) {
                    setLocalRange([localRange[0], newVal]);
                    onChange([localRange[0], newVal]);
                }
            };

            return (
                <div className="absolute bottom-8 left-4 z-[1000] bg-white/90 backdrop-blur-md p-4 rounded-xl shadow-2xl border border-white/50 w-72">
                    <h3 className="font-bold text-gray-800 text-sm mb-3 flex items-center gap-2">
                        <span className="w-1.5 h-4 bg-blue-600 rounded-full"></span>
                        Timeline Filter
                    </h3>
                    
                    <div className="space-y-4">
                        <div className="relative h-2 bg-gray-200 rounded-full mt-2">
                             {/* Range Visualizer needed here if full slider, but native inputs are easier for MVP */}
                             <div className="absolute h-full bg-blue-500 rounded-full opacity-50" 
                                  style={{
                                      left: `${((localRange[0] - minDate) / (maxDate - minDate)) * 100}%`,
                                      right: `${100 - ((localRange[1] - minDate) / (maxDate - minDate)) * 100}%`
                                  }} />
                        </div>

                        <div className="flex justify-between text-xs font-medium text-gray-500 font-mono">
                            <span>{localRange[0]}</span>
                            <span>{localRange[1]}</span>
                        </div>

                        <div className="flex flex-col gap-2">
                             <label className="text-xs text-gray-400">From Year</label>
                             <input 
                                type="range" 
                                min={minDate} 
                                max={maxDate} 
                                value={localRange[0]} 
                                onChange={handleMinChange}
                                className="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                             />
                             <label className="text-xs text-gray-400 mt-1">To Year</label>
                             <input 
                                type="range" 
                                min={minDate} 
                                max={maxDate} 
                                value={localRange[1]} 
                                onChange={handleMaxChange}
                                className="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                             />
                        </div>
                    </div>
                </div>
            );
        };

        const WikiMap = () => {
            const mapRef = React.useRef(null);
            const mapInstanceRef = React.useRef(null);
            const markersLayerRef = React.useRef(null);
            const [dateRange, setDateRange] = React.useState([1000, 2024]);
            
            // Debounce the fetch to avoid spamming while dragging
            // Simple timeout ref approach
            const fetchTimeoutRef = React.useRef(null);

            const fetchArticles = async (bounds, range) => {
                if (fetchTimeoutRef.current) clearTimeout(fetchTimeoutRef.current);

                fetchTimeoutRef.current = setTimeout(async () => {
                    try {
                        // Format bounds for backend: min_lon,min_lat,max_lon,max_lat
                        const bbox = [
                            bounds.getWest(),
                            bounds.getSouth(),
                            bounds.getEast(),
                            bounds.getNorth()
                        ].join(',');
                        
                        const zoom = mapInstanceRef.current ? mapInstanceRef.current.getZoom() : 13;

                        // Add date filters
                        const [minYear, maxYear] = range;

                        const response = await fetch(`/api/articles/?in_bbox=${bbox}&zoom=${zoom}&min_year=${minYear}&max_year=${maxYear}&format=json`);
                        if (!response.ok) throw new Error('Network response was not ok');
                        const data = await response.json();
                        
                        updateMarkers(data);
                    } catch (error) {
                        console.error("Failed to fetch articles:", error);
                    }
                }, 300); // 300ms debounce
            };

            const updateMarkers = (geojson) => {
                if (!markersLayerRef.current) return;
                
                markersLayerRef.current.clearLayers();
                
                const createClusterIcon = (count) => {
                    let size, className;

                    if (count < 10) {
                        size = 32;
                        className = 'cluster-small';
                    } else if (count < 100) {
                        size = 40;
                        className = 'cluster-medium';
                    } else if (count < 1000) {
                        size = 48;
                        className = 'cluster-large';
                    } else {
                        size = 56;
                        className = 'cluster-huge';
                    }

                    return L.divIcon({
                        html: `<div class="cluster-marker ${className}" style="width: ${size}px; height: ${size}px; font-size: ${Math.max(10, size/2.5)}px;">${count}</div>`,
                        className: 'custom-cluster-icon', // Wrapper class for Leaflet
                        iconSize: L.point(size, size),
                        iconAnchor: [size / 2, size / 2] // Center the icon
                    });
                };

                L.geoJSON(geojson, {
                    pointToLayer: (feature, latlng) => {
                        // Check if it's a server-side cluster
                        if (feature.properties && feature.properties.is_cluster && feature.properties.count > 1) {
                            return L.marker(latlng, {
                                icon: createClusterIcon(feature.properties.count)
                            });
                        }
                        
                        // Standard Article Marker - improved look
                        const wikiIcon = L.icon({
                            iconUrl: '{% static "svg/Wikipedia-logo-v2.svg" %}',
                            iconSize: [32, 32], // Default size
                            iconAnchor: [16, 16], // Center anchor
                            popupAnchor: [0, -16], // Popup above
                            className: 'marker-transition'
                        });

                        return L.marker(latlng, {
                            icon: wikiIcon,
                            title: feature.properties.title
                        });
                    },
                    onEachFeature: (feature, layer) => {
                        if (feature.properties && feature.properties.title) {
                            layer.bindPopup(`
                                <div class="p-3" style="width: 240px;">
                                    <h3 class="font-bold text-gray-900 text-base mb-1 truncate" title="${feature.properties.title}">${feature.properties.title}</h3>
                                    <div class="flex items-center gap-2 text-xs text-gray-500 mb-2">
                                        <span class="bg-gray-100 px-2 py-0.5 rounded-full">Oldest: ${feature.properties.oldest_date || 'N/A'}</span>
                                    </div>
                                    <a href="https://en.wikipedia.org/wiki/${feature.properties.title}" 
                                       target="_blank"
                                       class="inline-flex items-center justify-center w-full px-3 py-1.5 bg-blue-50 text-blue-600 hover:bg-blue-100 rounded-md text-sm font-medium transition-colors">
                                       Read Article â†’
                                    </a>
                                </div>
                            `, {
                                closeButton: false,
                                className: 'custom-popup'
                            });
                            
                            // Add hover effect
                            layer.on('mouseover', function() {
                                const currentIcon = this.options.icon;
                                this.setIcon(L.icon({
                                    ...currentIcon.options,
                                    iconSize: [40, 40], // Scale up
                                    iconAnchor: [20, 20] // Adjust anchor
                                }));
                            });
                            layer.on('mouseout', function() {
                                const currentIcon = this.options.icon;
                                this.setIcon(L.icon({
                                    ...currentIcon.options,
                                    iconSize: [32, 32], // Back to normal
                                    iconAnchor: [16, 16] // Back to normal anchor
                                }));
                            });

                            // Add click listener for summary
                            layer.on('click', async () => {
                                const title = feature.properties.title;
                                const popupContent = layer.getPopup().getContent();
                                // Temporary loading state in popup
                                layer.setPopupContent(`
                                    <div class="p-0 overflow-hidden rounded-lg font-sans" style="width: 280px;">
                                        <div class="p-4">
                                            <h3 class="font-bold text-gray-900 text-lg mb-2 leading-tight">${title}</h3>
                                            <div class="animate-pulse space-y-2">
                                                <div class="h-32 bg-gray-200 rounded mb-2 w-full"></div>
                                                <div class="h-4 bg-gray-200 rounded w-3/4"></div>
                                                <div class="h-4 bg-gray-200 rounded"></div>
                                                <div class="h-4 bg-gray-200 rounded w-5/6"></div>
                                            </div>
                                        </div>
                                    </div>
                                `);
                                
                                try {
                                    const response = await fetch(`/api/summary/${title}/`);
                                    if (!response.ok) throw new Error('Failed to fetch summary');
                                    const data = await response.json();
                                    
                                    const imageUrl = data.thumbnail ? data.thumbnail.source : null;
                                    const summary = data.extract ? (data.extract.length > 100 ? data.extract.substring(0, 100) + '...' : data.extract) : 'No summary available.';
                                    
                                    layer.setPopupContent(`
                                        <div class="p-0 overflow-hidden rounded-lg font-sans" style="width: 280px;">
                                            ${imageUrl ? `<div class="w-full h-32 bg-gray-100 bg-cover bg-center" style="background-image: url('${imageUrl}');"></div>` : ''}
                                            <div class="p-4">
                                                <h3 class="font-bold text-gray-900 text-lg mb-1 leading-tight">${data.title}</h3>
                                                <p class="text-sm text-gray-600 mb-3 line-clamp-3">${summary}</p>
                                                <div class="flex items-center justify-between">
                                                    <span class="text-xs text-gray-400">Oldest: ${feature.properties.oldest_date || 'N/A'}</span>
                                                    <a href="https://en.wikipedia.org/wiki/${title}" 
                                                       target="_blank"
                                                       class="inline-flex items-center justify-center px-3 py-1.5 bg-white text-blue-600 text-xs font-semibold hover:bg-blue-50 rounded-md border border-blue-600 transition-colors uppercase tracking-wide">
                                                       Read More
                                                   </a>
                                                </div>
                                            </div>
                                        </div>
                                    `);
                                } catch (error) {
                                    console.error("Error fetching summary:", error);
                                     layer.setPopupContent(`
                                        <div class="p-3">
                                            <p class="text-red-500 text-sm">Failed to load summary.</p>
                                        </div>
                                    `);
                                }
                            });
                            
                        } else if (feature.properties && feature.properties.is_cluster) {
                            // Cluster click -> Zoom in
                            layer.on('click', () => {
                                mapInstanceRef.current.setView(layer.getLatLng(), mapInstanceRef.current.getZoom() + 2);
                            });
                        }
                    }
                }).addTo(markersLayerRef.current);
            };

            const handleDateChange = (newRange) => {
                setDateRange(newRange);
                // Trigger fetch with new range
                if (mapInstanceRef.current) {
                    fetchArticles(mapInstanceRef.current.getBounds(), newRange);
                }
            };

            React.useEffect(() => {
                if (!mapRef.current) return;
                
                // Initialize Map
                // Default view: Dublin
                const map = L.map(mapRef.current).setView([53.3498, -6.2606], 13);
                mapInstanceRef.current = map;

                // Define Base Layers
                const streetLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                });

                const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
                });

                // Add default layer
                streetLayer.addTo(map);

                // Add Layer Control
                const baseMaps = {
                    "Street View": streetLayer,
                    "Satellite": satelliteLayer
                };
                L.control.layers(baseMaps, null, { position: 'topright' }).addTo(map);

                // Initialize Markers Layer Group (Standard Layer, not MarkerCluster anymore for server-side clusters)
                const markersLayer = L.layerGroup().addTo(map);
                markersLayerRef.current = markersLayer;

                // Event Listeners for Moving
                const onMoveEnd = () => {
                    // Use CURRENT dateRange from state? No, effect closure issue.
                    // Need to use refs or dependency array. Dependency array refreshes map which is bad.
                    // Best way: pass current values to fetch function manually or use refs for state.
                    // Actually, we can just use the latest value since we are inside a functional component...
                    // WAIT, the listener is attached once. It will capture stale state.
                    // Use a ref for dateRange to access inside the event callback.
                };
                
                // We need a stable reference to dateRange for the event listener
                // Or just re-attach listener? No.
                // Use a ref to store current dateRange
                
                // Moved logic to a separate useEffect for listener attachment or use a Ref.
                
                // Initial fetch
                fetchArticles(map.getBounds(), [1000, 2024]);

                // Cleanup
                return () => {
                    map.remove();
                };
            }, []);

            // Ref to store current date range for event listeners
            const dateRangeRef = React.useRef(dateRange);
            React.useEffect(() => {
                dateRangeRef.current = dateRange;
            }, [dateRange]);

            // Separate effect for moveend listener to avoid re-initializing map
            React.useEffect(() => {
                if (!mapInstanceRef.current) return;
                
                const onMoveEnd = () => {
                    fetchArticles(mapInstanceRef.current.getBounds(), dateRangeRef.current);
                };
                
                mapInstanceRef.current.on('moveend', onMoveEnd);
                
                return () => {
                    mapInstanceRef.current.off('moveend', onMoveEnd);
                };
            }, []);

            return (
                <div className="w-full h-full relative">
                    <div ref={mapRef} id="map-container" className="rounded-lg shadow-inner" />
                    
                    <TimelineControl 
                        minDate={1000} 
                        maxDate={2024} 
                        currentRange={dateRange} 
                        onChange={handleDateChange} 
                    />

                    {/* Floating Controls or Info could go here */}
                    <div className="absolute bottom-6 right-6 z-[1000] bg-white/90 p-2 rounded-lg shadow-lg backdrop-blur-sm text-xs text-gray-600">
                        Viewport-based loading
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('map-root'));
        root.render(<WikiMap />);
    </script>
{% endblock %}
