{% extends 'base.html' %}
{% load static %}

{% block title %}WikiMap - Explore{% endblock %}
{% block main_classes %}flex-grow w-full pt-16{% endblock %}

{% block extra_head %}
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <!-- Leaflet MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    
    <style>
        /* Ensure map takes full available height */
        #map-container {
            height: calc(100vh - 4rem - env(safe-area-inset-top));
            width: 100%;
            z-index: 0;
            background-color: #f8fafc; /* Light elegant background for map container */
        }

        /* Marker Cluster Animations & Styles */
        .custom-cluster-icon {
            /* No transition on the wrapper to prevent positioning glitches (floating markers) */
        }
        .custom-cluster-icon:hover {
            z-index: 1000 !important;
        }

        /* Safe transitions for individual markers */
        .marker-transition {
            transition-property: fill, stroke, r;
            transition-duration: 0.3s;
            transition-timing-function: ease-out;
        }

        .cluster-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: white;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            font-weight: 700;
            box-shadow: 
                0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                0 2px 4px -1px rgba(0, 0, 0, 0.06),
                inset 0 1px 1px rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            backdrop-filter: blur(4px);
        }

        .cluster-small {
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%); /* Blue-400 to Blue-500 */
        }
        .cluster-medium {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); /* Blue-500 to Blue-600 */
        }
        .cluster-large {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%); /* Blue-600 to Blue-700 */
        }
        .cluster-huge {
            background: linear-gradient(135deg, #1d4ed8 0%, #1e40af 100%); /* Blue-700 to Blue-800 */
        }
    </style>
{% endblock %}

{% block content %}
    <div id="map-root" class="w-full h-full relative"></div>
{% endblock %}

{% block extra_scripts %}
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- Leaflet MarkerCluster JS -->
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>

    <script type="text/babel">
        // Timeline Control Component
        // Search Bar Component
        const SearchBar = ({ onSelect }) => {
            const [query, setQuery] = React.useState('');
            const [results, setResults] = React.useState([]);
            const [isOpen, setIsOpen] = React.useState(false);
            const wrapperRef = React.useRef(null);
            
            // Debounce logic
            React.useEffect(() => {
                const timer = setTimeout(async () => {
                    if (query.trim().length < 2) {
                        setResults([]);
                        console.log("Query too short, clearing results");
                        return;
                    }

                    console.log("Fetching search results for:", query);
                    try {
                        const response = await fetch(`/api/search/?query=${encodeURIComponent(query)}`);
                        if (response.ok) {
                            const data = await response.json();
                            console.log("Search results received:", data);
                            
                            // Handle GeoJSON FeatureCollection
                            const features = data.features || [];
                            setResults(features);
                            
                            if (features.length > 0) {
                                setIsOpen(true);
                                console.log("Opening dropdown");
                            } else {
                                setIsOpen(false);
                            }
                        } else {
                            console.error("Search response not ok:", response.status);
                        }
                    } catch (error) {
                        console.error("Search failed:", error);
                    }
                }, 400);

                return () => clearTimeout(timer);
            }, [query]);

            // Click outside to close
            React.useEffect(() => {
                const handleClickOutside = (event) => {
                    if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
                        setIsOpen(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, []);

            const handleSelect = (article) => {
                setQuery(article.properties.title);
                setIsOpen(false);
                onSelect(article);
            };

            return (
                <div ref={wrapperRef} className="absolute top-4 right-14 z-40 w-64 bg-white/90 backdrop-blur-md rounded-lg shadow-xl border border-white/50">
                     <div className="relative">
                        <input
                            type="text"
                            className="w-full px-4 py-2 pl-9 rounded-lg border-0 bg-transparent focus:ring-2 focus:ring-blue-500 focus:outline-none text-sm placeholder-gray-500"
                            placeholder="Search location..."
                            value={query}
                            onChange={(e) => setQuery(e.target.value)}
                            onFocus={() => query.length >= 2 && setIsOpen(true)}
                        />
                        <i className="fa-solid fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 text-xs"></i>
                    </div>

                    {isOpen && results.length > 0 && (
                        <div className="absolute top-full left-0 w-full mt-1 bg-white rounded-lg shadow-lg border border-gray-100 overflow-hidden max-h-60 overflow-y-auto">
                            {results.map((article) => (
                                <button
                                    key={article.id}
                                    onClick={() => handleSelect(article)}
                                    className="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors border-b border-gray-50 last:border-0"
                                >
                                    {article.properties.title}
                                </button>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const TimelineControl = ({ minDate, maxDate, currentRange, onChange }) => {
            const [localRange, setLocalRange] = React.useState(currentRange);
            const [minInput, setMinInput] = React.useState(currentRange[0].toString());
            const [maxInput, setMaxInput] = React.useState(currentRange[1].toString());

            React.useEffect(() => {
                setLocalRange(currentRange);
                setMinInput(currentRange[0].toString());
                setMaxInput(currentRange[1].toString());
            }, [currentRange]);

            const handleSliderMinChange = (e) => {
                const newVal = parseInt(e.target.value);
                if (newVal < localRange[1]) {
                    setLocalRange([newVal, localRange[1]]);
                    setMinInput(newVal.toString());
                    onChange([newVal, localRange[1]]);
                }
            };

            const handleSliderMaxChange = (e) => {
                const newVal = parseInt(e.target.value);
                if (newVal > localRange[0]) {
                    setLocalRange([localRange[0], newVal]);
                    setMaxInput(newVal.toString());
                    onChange([localRange[0], newVal]);
                }
            };

            const commitMinChange = () => {
                let newVal = parseInt(minInput);
                if (isNaN(newVal)) {
                    setMinInput(localRange[0].toString()); // Revert
                    return;
                }
                // Clamp
                newVal = Math.max(minDate, Math.min(newVal, localRange[1]));
                
                setLocalRange([newVal, localRange[1]]);
                setMinInput(newVal.toString());
                onChange([newVal, localRange[1]]);
            };

            const commitMaxChange = () => {
                let newVal = parseInt(maxInput);
                if (isNaN(newVal)) {
                    setMaxInput(localRange[1].toString()); // Revert
                    return;
                }
                // Clamp
                newVal = Math.min(maxDate, Math.max(newVal, localRange[0]));
                
                setLocalRange([localRange[0], newVal]);
                setMaxInput(newVal.toString());
                onChange([localRange[0], newVal]);
            };

            const handleKeyDown = (e, callback) => {
                if (e.key === 'Enter') {
                    callback();
                    e.target.blur();
                }
            };

            return (
                <div className="absolute bottom-8 left-4 z-[1000] bg-white/90 backdrop-blur-md p-4 rounded-xl shadow-2xl border border-white/50 w-72">
                    <h3 className="font-bold text-gray-800 text-sm mb-3 flex items-center gap-2">
                        <span className="w-1.5 h-4 bg-blue-600 rounded-full"></span>
                        Timeline Filter
                    </h3>
                    
                    <div className="space-y-4">
                        <div className="relative h-2 bg-gray-200 rounded-full mt-2">
                             <div className="absolute h-full bg-blue-500 rounded-full opacity-50" 
                                  style={{
                                      left: `${((localRange[0] - minDate) / (maxDate - minDate)) * 100}%`,
                                      right: `${100 - ((localRange[1] - minDate) / (maxDate - minDate)) * 100}%`
                                  }} />
                        </div>

                        <div className="flex justify-between items-center gap-2">
                            <div className="flex flex-col gap-1 w-full">
                                <label className="text-xs text-gray-500 font-semibold">Start Year</label>
                                <input 
                                    type="number" 
                                    value={minInput} 
                                    onChange={(e) => setMinInput(e.target.value)}
                                    onBlur={commitMinChange}
                                    onKeyDown={(e) => handleKeyDown(e, commitMinChange)}
                                    className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:outline-none"
                                />
                            </div>
                            <div className="flex flex-col gap-1 w-full">
                                <label className="text-xs text-gray-500 font-semibold text-right">End Year</label>
                                <input 
                                    type="number" 
                                    value={maxInput} 
                                    onChange={(e) => setMaxInput(e.target.value)}
                                    onBlur={commitMaxChange}
                                    onKeyDown={(e) => handleKeyDown(e, commitMaxChange)}
                                    className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:outline-none text-right"
                                />
                            </div>
                        </div>

                        <div className="flex flex-col gap-2 pt-1">
                             <input 
                                type="range" 
                                min={minDate} 
                                max={maxDate} 
                                value={localRange[0]} 
                                onChange={handleSliderMinChange}
                                className="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                             />
                             <input 
                                type="range" 
                                min={minDate} 
                                max={maxDate} 
                                value={localRange[1]} 
                                onChange={handleSliderMaxChange}
                                className="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                             />
                        </div>
                    </div>
                </div>
            );
        };

        const WikiMap = () => {
            const mapRef = React.useRef(null);
            const mapInstanceRef = React.useRef(null);
            const markersLayerRef = React.useRef(null);
            const [dateRange, setDateRange] = React.useState([1000, 2024]);
            
            // Debounce the fetch to avoid spamming while dragging
            // Simple timeout ref approach
            const fetchTimeoutRef = React.useRef(null);

            const fetchArticles = async (bounds, range) => {
                if (fetchTimeoutRef.current) clearTimeout(fetchTimeoutRef.current);

                fetchTimeoutRef.current = setTimeout(async () => {
                    try {
                        // Format bounds for backend: min_lon,min_lat,max_lon,max_lat
                        const bbox = [
                            bounds.getWest(),
                            bounds.getSouth(),
                            bounds.getEast(),
                            bounds.getNorth()
                        ].join(',');
                        
                        const zoom = mapInstanceRef.current ? mapInstanceRef.current.getZoom() : 13;

                        // Add date filters
                        const [minYear, maxYear] = range;

                        const response = await fetch(`/api/articles/?in_bbox=${bbox}&zoom=${zoom}&min_year=${minYear}&max_year=${maxYear}&format=json`);
                        if (!response.ok) throw new Error('Network response was not ok');
                        const data = await response.json();
                        
                        updateMarkers(data);
                    } catch (error) {
                        console.error("Failed to fetch articles:", error);
                    }
                }, 300); // 300ms debounce
            };

            const registryRef = React.useRef({});

            const createMarker = (feature, latlng) => {
                let marker;
                
                // Cluster
                if (feature.properties && feature.properties.is_cluster && feature.properties.count > 1) {
                     const count = feature.properties.count;
                     let size, className;

                     if (count < 10) {
                         size = 32;
                         className = 'cluster-small';
                     } else if (count < 100) {
                         size = 40;
                         className = 'cluster-medium';
                     } else if (count < 1000) {
                         size = 48;
                         className = 'cluster-large';
                     } else {
                         size = 56;
                         className = 'cluster-huge';
                     }

                     const icon = L.divIcon({
                         html: `<div class="cluster-marker ${className}" style="width: ${size}px; height: ${size}px; font-size: ${Math.max(10, size/2.5)}px;">${count}</div>`,
                         className: 'custom-cluster-icon',
                         iconSize: L.point(size, size),
                         iconAnchor: [size / 2, size / 2]
                     });
                     
                     marker = L.marker(latlng, { icon });
                     
                     // Cluster click -> Zoom in
                     marker.on('click', () => {
                         if (mapInstanceRef.current) {
                             mapInstanceRef.current.setView(latlng, mapInstanceRef.current.getZoom() + 2);
                         }
                     });
                     
                } else {
                    // Standard Article Marker
                    const wikiIcon = L.icon({
                        iconUrl: '{% static "svg/Wikipedia-logo-v2.svg" %}',
                        iconSize: [32, 32],
                        iconAnchor: [16, 16],
                        popupAnchor: [0, -16],
                        className: 'marker-transition'
                    });

                    marker = L.marker(latlng, {
                        icon: wikiIcon,
                        title: feature.properties.title
                    });
                    
                    if (feature.properties && feature.properties.title) {
                         marker.bindPopup(`
                            <div class="p-3" style="width: 240px;">
                                <h3 class="font-bold text-gray-900 text-base mb-1 truncate" title="${feature.properties.title}">${feature.properties.title}</h3>
                                <div class="flex items-center gap-2 text-xs text-gray-500 mb-2">
                                    <span class="bg-gray-100 px-2 py-0.5 rounded-full">Oldest: ${feature.properties.oldest_date || 'N/A'}</span>
                                </div>
                                <a href="https://en.wikipedia.org/wiki/${feature.properties.title}" 
                                   target="_blank"
                                   class="inline-flex items-center justify-center w-full px-3 py-1.5 bg-blue-50 text-blue-600 hover:bg-blue-100 rounded-md text-sm font-medium transition-colors">
                                   Read Article â†’
                                </a>
                            </div>
                        `, {
                            closeButton: false,
                            className: 'custom-popup'
                        });
                        
                        // Hover effects
                        marker.on('mouseover', function() {
                            const currentIcon = this.options.icon;
                            this.setIcon(L.icon({
                                ...currentIcon.options,
                                iconSize: [40, 40],
                                iconAnchor: [20, 20]
                            }));
                        });
                        marker.on('mouseout', function() {
                            const currentIcon = this.options.icon;
                            this.setIcon(L.icon({
                                ...currentIcon.options,
                                iconSize: [32, 32],
                                iconAnchor: [16, 16]
                            }));
                        });

                        // Summary click
                        marker.on('click', async () => {
                            const title = feature.properties.title;
                            // Temporary loading state
                            marker.setPopupContent(`
                                <div class="p-0 overflow-hidden rounded-lg font-sans" style="width: 280px;">
                                    <div class="p-4">
                                        <h3 class="font-bold text-gray-900 text-lg mb-2 leading-tight">${title}</h3>
                                        <div class="animate-pulse space-y-2">
                                            <div class="h-32 bg-gray-200 rounded mb-2 w-full"></div>
                                            <div class="h-4 bg-gray-200 rounded w-3/4"></div>
                                            <div class="h-4 bg-gray-200 rounded"></div>
                                            <div class="h-4 bg-gray-200 rounded w-5/6"></div>
                                        </div>
                                    </div>
                                </div>
                            `);
                            
                            try {
                                const response = await fetch(`/api/summary/${encodeURIComponent(title)}/`);
                                if (!response.ok) throw new Error('Failed to fetch summary');
                                const data = await response.json();
                                
                                const imageUrl = data.thumbnail ? data.thumbnail.source : null;
                                const summary = data.extract ? (data.extract.length > 100 ? data.extract.substring(0, 100) + '...' : data.extract) : 'No summary available.';
                                
                                marker.setPopupContent(`
                                    <div class="p-0 overflow-hidden rounded-lg font-sans" style="width: 280px;">
                                        ${imageUrl ? `<div class="w-full h-32 bg-gray-100 bg-cover bg-center" style="background-image: url('${imageUrl}');"></div>` : ''}
                                        <div class="p-4">
                                            <h3 class="font-bold text-gray-900 text-lg mb-1 leading-tight">${data.title}</h3>
                                            <p class="text-sm text-gray-600 mb-3 line-clamp-3">${summary}</p>
                                            <div class="flex items-center justify-between">
                                                <span class="text-xs text-gray-400">Oldest: ${feature.properties.oldest_date || 'N/A'}</span>
                                                <a href="https://en.wikipedia.org/wiki/${title}" 
                                                   target="_blank"
                                                   class="inline-flex items-center justify-center px-3 py-1.5 bg-white text-blue-600 text-xs font-semibold hover:bg-blue-50 rounded-md border border-blue-600 transition-colors uppercase tracking-wide">
                                                   Read More
                                                </a>
                                            </div>
                                        </div>
                                    </div>
                                `);
                            } catch (error) {
                                console.error("Error fetching summary:", error);
                                 marker.setPopupContent(`
                                    <div class="p-3">
                                        <p class="text-red-500 text-sm">Failed to load summary.</p>
                                    </div>
                                `);
                            }
                        });
                    }
                }
                return marker;
            };

            const updateMarkers = (geojson) => {
                if (!markersLayerRef.current) return;
                
                const features = geojson.features || [];
                const seenKeys = new Set();
                
                features.forEach(feature => {
                    let key;
                    const coords = feature.geometry.coordinates; // [lon, lat]
                    
                    if (feature.properties && feature.properties.is_cluster) {
                        key = `cluster_${coords[0]}_${coords[1]}_${feature.properties.count}`;
                    } else if (feature.id) {
                        key = `article_${feature.id}`;
                    } else {
                        // Fallback
                        key = `item_${coords[0]}_${coords[1]}`;
                    }
                    
                    seenKeys.add(key);
                    
                    if (!registryRef.current[key]) {
                        // Create new marker
                        const latlng = [coords[1], coords[0]]; // Leaflet uses [lat, lon]
                        const marker = createMarker(feature, latlng);
                        marker.addTo(markersLayerRef.current);
                        registryRef.current[key] = marker;
                    }
                });
                
                // Cleanup old markers
                Object.keys(registryRef.current).forEach(key => {
                    if (!seenKeys.has(key)) {
                        const marker = registryRef.current[key];
                        // Don't remove if it's currently open? No, if it's gone from backend, remove it.
                        // But user issue was panning causing refresh. If panned only slightly, 
                        // the open marker SHOULD still be in 'features' so it will be in 'seenKeys'.
                        // So removing unseen is correct.
                        markersLayerRef.current.removeLayer(marker);
                        delete registryRef.current[key];
                    }
                });
            };

            const handleSearchSelect = (article) => {
                if (mapInstanceRef.current && article.geometry && article.geometry.coordinates) {
                    const [lon, lat] = article.geometry.coordinates;
                    mapInstanceRef.current.flyTo([lat, lon], 16, {
                        animate: true,
                        duration: 1.5
                    });
                }
            };

            const handleDateChange = (newRange) => {
                setDateRange(newRange);
                // Trigger fetch with new range
                if (mapInstanceRef.current) {
                    fetchArticles(mapInstanceRef.current.getBounds(), newRange);
                }
            };

            React.useEffect(() => {
                if (!mapRef.current) return;
                
                // Initialize Map
                // Default view: Dublin
                const map = L.map(mapRef.current).setView([53.3498, -6.2606], 13);
                mapInstanceRef.current = map;

                // Define Base Layers
                const streetLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                });

                const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
                });

                // Add default layer
                streetLayer.addTo(map);

                // Add Layer Control
                const baseMaps = {
                    "Street View": streetLayer,
                    "Satellite": satelliteLayer
                };
                L.control.layers(baseMaps, null, { position: 'topright' }).addTo(map);

                // Initialize Markers Layer Group (Standard Layer, not MarkerCluster anymore for server-side clusters)
                const markersLayer = L.layerGroup().addTo(map);
                markersLayerRef.current = markersLayer;

                // Event Listeners for Moving
                const onMoveEnd = () => {
                    // Use CURRENT dateRange from state? No, effect closure issue.
                    // Need to use refs or dependency array. Dependency array refreshes map which is bad.
                    // Best way: pass current values to fetch function manually or use refs for state.
                    // Actually, we can just use the latest value since we are inside a functional component...
                    // WAIT, the listener is attached once. It will capture stale state.
                    // Use a ref for dateRange to access inside the event callback.
                };
                
                // We need a stable reference to dateRange for the event listener
                // Or just re-attach listener? No.
                // Use a ref to store current dateRange
                
                // Moved logic to a separate useEffect for listener attachment or use a Ref.
                
                // Initial fetch
                fetchArticles(map.getBounds(), [1000, 2024]);

                // Cleanup
                return () => {
                    map.remove();
                };
            }, []);

            // Ref to store current date range for event listeners
            const dateRangeRef = React.useRef(dateRange);
            React.useEffect(() => {
                dateRangeRef.current = dateRange;
            }, [dateRange]);

            // Separate effect for moveend listener to avoid re-initializing map
            React.useEffect(() => {
                if (!mapInstanceRef.current) return;
                
                const onMoveEnd = () => {
                    fetchArticles(mapInstanceRef.current.getBounds(), dateRangeRef.current);
                };
                
                mapInstanceRef.current.on('moveend', onMoveEnd);
                
                return () => {
                    mapInstanceRef.current.off('moveend', onMoveEnd);
                };
            }, []);

            return (
                <div className="w-full h-full relative">
                    <div ref={mapRef} id="map-container" className="rounded-lg shadow-inner" />
                    
                    <SearchBar onSelect={handleSearchSelect} />

                    <TimelineControl 
                        minDate={1000} 
                        maxDate={2024} 
                        currentRange={dateRange} 
                        onChange={handleDateChange} 
                    />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('map-root'));
        root.render(<WikiMap />);
    </script>
{% endblock %}
