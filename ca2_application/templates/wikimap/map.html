{% extends 'base.html' %}
{% load static %}

{% block title %}WikiMap - Explore{% endblock %}
{% block main_classes %}flex-grow w-full pt-16{% endblock %}

{% block extra_head %}
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <!-- Leaflet MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    
    <style>
        /* Ensure map takes full available height */
        #map-container {
            height: calc(100dvh - 4rem - env(safe-area-inset-top));
            width: 100%;
            z-index: 0;
            background-color: #f8fafc; /* Light elegant background for map container */
        }

        /* Marker Cluster Animations & Styles */
        .custom-cluster-icon {
            /* No transition on the wrapper to prevent positioning glitches (floating markers) */
        }
        .custom-cluster-icon:hover {
            z-index: 1000 !important;
        }

        /* Safe transitions for individual markers */
        .marker-transition {
            transition-property: fill, stroke, r;
            transition-duration: 0.3s;
            transition-timing-function: ease-out;
        }

        .cluster-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: white;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            font-weight: 700;
            box-shadow: 
                0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                0 2px 4px -1px rgba(0, 0, 0, 0.06),
                inset 0 1px 1px rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            backdrop-filter: blur(4px);
        }

        .cluster-small {
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%); /* Blue-400 to Blue-500 */
        }
        .cluster-medium {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); /* Blue-500 to Blue-600 */
        }
        .cluster-large {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%); /* Blue-600 to Blue-700 */
        }
        .cluster-huge {
            background: linear-gradient(135deg, #1d4ed8 0%, #1e40af 100%); /* Blue-700 to Blue-800 */
        }

        .marker-in-range {
            filter: drop-shadow(0 0 8px #22c55e) !important; /* Green-500 glow */
            z-index: 1000 !important;
        }
        
        footer {
            display: none;
        }

    </style>
{% endblock %}

{% block content %}
    <div id="map-root" class="w-full h-full relative"></div>
{% endblock %}

{% block extra_scripts %}
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- Leaflet MarkerCluster JS -->
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>

    <script type="text/babel">
        // Timeline Control Component
        // Search Bar Component
        const SearchBar = ({ onSelect }) => {
            const [query, setQuery] = React.useState('');
            const [results, setResults] = React.useState([]);
            const [isOpen, setIsOpen] = React.useState(false);
            const wrapperRef = React.useRef(null);
            
            // Debounce logic
            React.useEffect(() => {
                const timer = setTimeout(async () => {
                    if (query.trim().length < 2) {
                        setResults([]);
                        console.log("Query too short, clearing results");
                        return;
                    }

                    console.log("Fetching search results for:", query);
                    try {
                        const response = await fetch(`/api/search/?query=${encodeURIComponent(query)}`);
                        if (response.ok) {
                            const data = await response.json();
                            console.log("Search results received:", data);
                            
                            // Handle GeoJSON FeatureCollection
                            const features = data.features || [];
                            setResults(features);
                            
                            if (features.length > 0) {
                                setIsOpen(true);
                                console.log("Opening dropdown");
                            } else {
                                setIsOpen(false);
                            }
                        } else {
                            console.error("Search response not ok:", response.status);
                        }
                    } catch (error) {
                        console.error("Search failed:", error);
                    }
                }, 400);

                return () => clearTimeout(timer);
            }, [query]);

            // Click outside to close
            React.useEffect(() => {
                const handleClickOutside = (event) => {
                    if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
                        setIsOpen(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, []);

            const handleSelect = (article) => {
                setQuery(article.properties.title);
                setIsOpen(false);
                onSelect(article);
            };

            return (
                <div ref={wrapperRef} className="fixed top-[4.5rem] left-2 right-2 md:absolute md:top-4 md:right-14 md:left-auto md:w-64 z-40 bg-white/90 backdrop-blur-md rounded-lg shadow-xl border border-white/50">
                     <div className="relative">
                        <input
                            type="text"
                            className="w-full px-4 py-2 pl-9 rounded-lg border-0 bg-transparent focus:ring-2 focus:ring-blue-500 focus:outline-none text-sm placeholder-gray-500"
                            placeholder="Search location..."
                            value={query}
                            onChange={(e) => setQuery(e.target.value)}
                            onFocus={() => query.length >= 2 && setIsOpen(true)}
                        />
                        <i className="fa-solid fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 text-xs"></i>
                    </div>

                    {isOpen && results.length > 0 && (
                        <div className="absolute top-full left-0 w-full mt-1 bg-white rounded-lg shadow-lg border border-gray-100 overflow-hidden max-h-60 overflow-y-auto">
                            {results.map((article) => (
                                <button
                                    key={article.id}
                                    onClick={() => handleSelect(article)}
                                    className="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors border-b border-gray-50 last:border-0"
                                >
                                    {article.properties.title}
                                </button>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const TimelineControl = ({ minDate, maxDate, currentRange, onChange }) => {
            const [localRange, setLocalRange] = React.useState(currentRange);
            const [minInput, setMinInput] = React.useState(currentRange[0].toString());
            const [maxInput, setMaxInput] = React.useState(currentRange[1].toString());

            React.useEffect(() => {
                setLocalRange(currentRange);
                setMinInput(currentRange[0].toString());
                setMaxInput(currentRange[1].toString());
            }, [currentRange]);

            const handleSliderMinChange = (e) => {
                const newVal = parseInt(e.target.value);
                if (newVal < localRange[1]) {
                    setLocalRange([newVal, localRange[1]]);
                    setMinInput(newVal.toString());
                    onChange([newVal, localRange[1]]);
                }
            };

            const handleSliderMaxChange = (e) => {
                const newVal = parseInt(e.target.value);
                if (newVal > localRange[0]) {
                    setLocalRange([localRange[0], newVal]);
                    setMaxInput(newVal.toString());
                    onChange([localRange[0], newVal]);
                }
            };

            const commitMinChange = () => {
                let newVal = parseInt(minInput);
                if (isNaN(newVal)) {
                    setMinInput(localRange[0].toString()); // Revert
                    return;
                }
                // Clamp
                newVal = Math.max(minDate, Math.min(newVal, localRange[1]));
                
                setLocalRange([newVal, localRange[1]]);
                setMinInput(newVal.toString());
                onChange([newVal, localRange[1]]);
            };

            const commitMaxChange = () => {
                let newVal = parseInt(maxInput);
                if (isNaN(newVal)) {
                    setMaxInput(localRange[1].toString()); // Revert
                    return;
                }
                // Clamp
                newVal = Math.min(maxDate, Math.max(newVal, localRange[0]));
                
                setLocalRange([localRange[0], newVal]);
                setMaxInput(newVal.toString());
                onChange([localRange[0], newVal]);
            };

            const handleKeyDown = (e, callback) => {
                if (e.key === 'Enter') {
                    callback();
                    e.target.blur();
                }
            };

            return (
                <div className="absolute bottom-6 left-2 right-2 md:left-4 md:right-auto md:bottom-8 z-[1000] bg-white/90 backdrop-blur-md p-3 md:p-4 rounded-xl shadow-2xl border border-white/50 w-auto md:w-72 flex flex-col gap-2 md:block">
                    <h3 className="font-bold text-gray-800 text-xs md:text-sm mb-1 md:mb-3 flex items-center gap-2">
                        <span className="w-1.5 h-3 md:h-4 bg-blue-600 rounded-full"></span>
                        Timeline Filter
                    </h3>
                    
                    <div className="space-y-3 md:space-y-4">
                        {/* Labels */}
                        <div className="flex justify-between items-center gap-2">
                            <div className="flex flex-col gap-0.5 md:gap-1 w-full">
                                <label className="text-[10px] md:text-xs text-gray-500 font-semibold">Start Year</label>
                                <input 
                                    type="number" 
                                    value={minInput} 
                                    onChange={(e) => setMinInput(e.target.value)}
                                    onBlur={commitMinChange}
                                    onKeyDown={(e) => handleKeyDown(e, commitMinChange)}
                                    className="w-full px-2 py-1 text-xs md:text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:outline-none"
                                />
                            </div>
                            <div className="flex flex-col gap-0.5 md:gap-1 w-full">
                                <label className="text-[10px] md:text-xs text-gray-500 font-semibold text-right">End Year</label>
                                <input 
                                    type="number" 
                                    value={maxInput} 
                                    onChange={(e) => setMaxInput(e.target.value)}
                                    onBlur={commitMaxChange}
                                    onKeyDown={(e) => handleKeyDown(e, commitMaxChange)}
                                    className="w-full px-2 py-1 text-xs md:text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:outline-none text-right"
                                />
                            </div>
                        </div>

                        {/* Combined Slider Track & Inputs */}
                        <div className="relative h-6 flex items-center">
                            <style>{`
          .range-slider-thumb::-webkit-slider-thumb {
            pointer-events: auto;
            appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            margin-top: -7px; /* Center thumb relative to track */
          }
          .range-slider-thumb::-moz-range-thumb {
            pointer-events: auto;
            border: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
          }
          .range-slider-input::-webkit-slider-runnable-track {
             background: transparent;
             height: 100%;
          }
          .range-slider-input::-moz-range-track {
             background: transparent;
             height: 100%;
          }
        `}</style>
                            
                            {/* Visual Track */}
                            <div className="absolute left-0 right-0 h-1.5 md:h-2 bg-gray-200 rounded-full z-0">
                                 <div className="absolute h-full bg-blue-500 rounded-full opacity-50" 
                                      style={{
                                          left: `${((localRange[0] - minDate) / (maxDate - minDate)) * 100}%`,
                                          right: `${100 - ((localRange[1] - minDate) / (maxDate - minDate)) * 100}%`
                                      }} />
                            </div>

                            {/* Range Inputs */}
                             <input 
                                type="range" 
                                min={minDate} 
                                max={maxDate} 
                                value={localRange[0]} 
                                onChange={handleSliderMinChange}
                                className="range-slider-input range-slider-thumb absolute top-1/2 left-0 w-full h-1 -translate-y-1/2 appearance-none bg-transparent pointer-events-none z-20 m-0 p-0"
                             />
                             <input 
                                type="range" 
                                min={minDate} 
                                max={maxDate} 
                                value={localRange[1]} 
                                onChange={handleSliderMaxChange}
                                className="range-slider-input range-slider-thumb absolute top-1/2 left-0 w-full h-1 -translate-y-1/2 appearance-none bg-transparent pointer-events-none z-20 m-0 p-0"
                             />
                        </div>
                    </div>
                </div>
            );
        };

        const Toast = ({ message, type, onClose }) => {
            React.useEffect(() => {
                const timer = setTimeout(() => {
                    onClose();
                }, 3000);
                return () => clearTimeout(timer);
            }, [onClose]);

            const bgClass = type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500';
            const icon = type === 'success' ? 'fa-check-circle' : type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle';

            return (
                <div className={`${bgClass} text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-3 min-w-[300px] animate-fade-in-up transition-all`}>
                    <i className={`fa-solid ${icon}`}></i>
                    <p className="font-medium text-sm flex-grow">{message}</p>
                    <button onClick={onClose} className="opacity-80 hover:opacity-100 transition-opacity">
                        <i className="fa-solid fa-times"></i>
                    </button>
                </div>
            );
        };

        const ToastContainer = ({ toasts, removeToast }) => {
            return (
                <div className="fixed top-20 right-4 z-[2000] flex flex-col gap-2 pointer-events-none">
                     {/* Allow pointer events on toasts themselves */}
                     <div className="flex flex-col gap-2 pointer-events-auto">
                        {toasts.map(toast => (
                            <Toast key={toast.id} message={toast.message} type={toast.type} onClose={() => removeToast(toast.id)} />
                        ))}
                    </div>
                </div>
            );
        };

        const LocationControl = ({ onLocate }) => {
            const [loading, setLoading] = React.useState(false);

            const handleClick = async () => {
                setLoading(true);
                try {
                    await onLocate();
                } finally {
                    setLoading(false);
                }
            };

            return (
                <button
                    onClick={handleClick}
                    className="absolute top-[8.5rem] right-2 md:top-24 md:right-3 z-[400] w-10 h-10 bg-white rounded-lg shadow-md border-2 border-slate-200 flex items-center justify-center text-slate-600 hover:text-blue-600 hover:border-blue-500 hover:bg-blue-50 transition-all focus:outline-none focus:ring-2 focus:ring-blue-500"
                    title="Show my location"
                >
                    {loading ? (
                        <i className="fa-solid fa-circle-notch fa-spin text-lg"></i>
                    ) : (
                        <i className="fa-solid fa-location-crosshairs text-lg"></i>
                    )}
                </button>
            );
        };


        const WikiMap = () => {
            const mapRef = React.useRef(null);
            const mapInstanceRef = React.useRef(null);
            const markersLayerRef = React.useRef(null);
            const userLocationLayerRef = React.useRef(null);
            const userCircleRef = React.useRef(null);
            const [dateRange, setDateRange] = React.useState([1000, 2024]);
            const [userLocation, setUserLocation] = React.useState(null);
            const userLocationRef = React.useRef(null); // Ref for access in callbacks
            const [toasts, setToasts] = React.useState([]);

            const addToast = (message, type = 'info') => {
                const id = Date.now();
                setToasts(prev => [...prev, { id, message, type }]);
            };

            const removeToast = (id) => {
                setToasts(prev => prev.filter(t => t.id !== id));
            };
            
            // Expose addToast to global scope via ref for the window function
            const addToastRef = React.useRef(addToast);
            React.useEffect(() => {
                addToastRef.current = addToast;
            }, [toasts]); // Update ref when toasts state changes (though function itself might be stable if defined outside, but inside component it recreates. Actually better to use a ref that persist across renders)

            // Better: use a Stable function ref
            const stableAddToast = React.useCallback((message, type) => {
                 const id = Date.now() + Math.random();
                 setToasts(prev => [...prev, { id, message, type }]);
            }, []);

            React.useEffect(() => {
                userLocationRef.current = userLocation;
            }, [userLocation]);
            
            // Debounce the fetch to avoid spamming while dragging
            // Simple timeout ref approach
            const fetchTimeoutRef = React.useRef(null);

            const fetchArticles = async (bounds, range) => {
                if (fetchTimeoutRef.current) clearTimeout(fetchTimeoutRef.current);

                fetchTimeoutRef.current = setTimeout(async () => {
                    try {
                        // Format bounds for backend: min_lon,min_lat,max_lon,max_lat
                        const bbox = [
                            bounds.getWest(),
                            bounds.getSouth(),
                            bounds.getEast(),
                            bounds.getNorth()
                        ].join(',');
                        
                        const zoom = mapInstanceRef.current ? mapInstanceRef.current.getZoom() : 13;

                        // Add date filters
                        const [minYear, maxYear] = range;

                        const response = await fetch(`/api/articles/?in_bbox=${bbox}&zoom=${zoom}&min_year=${minYear}&max_year=${maxYear}&format=json`);
                        if (!response.ok) throw new Error('Network response was not ok');
                        const data = await response.json();
                        
                        updateMarkers(data);
                    } catch (error) {
                        console.error("Failed to fetch articles:", error);
                    }
                }, 300); // 300ms debounce
            };

            const registryRef = React.useRef({});

            const createMarker = (feature, latlng) => {
                let marker;
                
                // Cluster
                if (feature.properties && feature.properties.is_cluster && feature.properties.count > 1) {
                     const count = feature.properties.count;
                     let size, className;

                     if (count < 10) {
                         size = 32;
                         className = 'cluster-small';
                     } else if (count < 100) {
                         size = 40;
                         className = 'cluster-medium';
                     } else if (count < 1000) {
                         size = 48;
                         className = 'cluster-large';
                     } else {
                         size = 56;
                         className = 'cluster-huge';
                     }

                     const icon = L.divIcon({
                         html: `<div class="cluster-marker ${className}" style="width: ${size}px; height: ${size}px; font-size: ${Math.max(10, size/2.5)}px;">${count}</div>`,
                         className: 'custom-cluster-icon',
                         iconSize: L.point(size, size),
                         iconAnchor: [size / 2, size / 2]
                     });
                     
                     marker = L.marker(latlng, { icon });
                     
                     // Cluster click -> Zoom in
                     marker.on('click', () => {
                         if (mapInstanceRef.current) {
                             mapInstanceRef.current.setView(latlng, mapInstanceRef.current.getZoom() + 2);
                         }
                     });
                     
                } else {
                    // Standard Article Marker
                    const wikiIcon = L.icon({
                        iconUrl: '{% static "svg/Wikipedia-logo-v2.svg" %}',
                        iconSize: [32, 32],
                        iconAnchor: [16, 16],
                        popupAnchor: [0, -16],
                        className: 'marker-transition'
                    });

                    marker = L.marker(latlng, {
                        icon: wikiIcon,
                        title: feature.properties.title
                    });
                    
                    if (feature.properties && feature.properties.title) {
                         marker.bindPopup(`
                            <div class="p-2 md:p-3" style="width: auto; min-width: 200px; max-width: 240px;">
                                <h3 class="font-bold text-gray-900 text-sm md:text-base mb-1 truncate" title="${feature.properties.title}">${feature.properties.title}</h3>
                                <div class="flex items-center gap-2 text-[10px] md:text-xs text-gray-500 mb-2">
                                    <span class="bg-gray-100 px-2 py-0.5 rounded-full">Oldest: ${feature.properties.oldest_date || 'N/A'}</span>
                                </div>
                                <a href="https://en.wikipedia.org/wiki/${feature.properties.title}" 
                                   target="_blank"
                                   class="inline-flex items-center justify-center w-full px-3 py-1.5 bg-blue-50 text-blue-600 hover:bg-blue-100 rounded-md text-xs md:text-sm font-medium transition-colors">
                                   Read Article â†’
                                </a>
                            </div>
                        `, {
                            closeButton: false,
                            className: 'custom-popup'
                        });
                        
                        // Hover effects
                        marker.on('mouseover', function() {
                            const currentIcon = this.options.icon;
                            this.setIcon(L.icon({
                                ...currentIcon.options,
                                iconSize: [40, 40],
                                iconAnchor: [20, 20]
                            }));
                        });
                        marker.on('mouseout', function() {
                            const currentIcon = this.options.icon;
                            this.setIcon(L.icon({
                                ...currentIcon.options,
                                iconSize: [32, 32],
                                iconAnchor: [16, 16]
                            }));
                        });

                        // Summary click
                        marker.on('click', async () => {
                            const title = feature.properties.title;
                            // Temporary loading state
                            marker.setPopupContent(`
                                <div class="p-0 overflow-hidden rounded-lg font-sans" style="width: auto; min-width: 220px; max-width: 280px;">
                                    <div class="p-3 md:p-4">
                                        <h3 class="font-bold text-gray-900 text-base md:text-lg mb-2 leading-tight">${title}</h3>
                                        <div class="animate-pulse space-y-2">
                                            <div class="h-24 md:h-32 bg-gray-200 rounded mb-2 w-full"></div>
                                            <div class="h-3 md:h-4 bg-gray-200 rounded w-3/4"></div>
                                            <div class="h-3 md:h-4 bg-gray-200 rounded"></div>
                                            <div class="h-3 md:h-4 bg-gray-200 rounded w-5/6"></div>
                                        </div>
                                    </div>
                                </div>
                            `);
                            
                            try {
                                const response = await fetch(`/api/summary/${encodeURIComponent(title)}/`);
                                if (!response.ok) throw new Error('Failed to fetch summary');
                                const data = await response.json();
                                
                                const imageUrl = data.thumbnail ? data.thumbnail.source : null;
                                const summary = data.extract ? (data.extract.length > 100 ? data.extract.substring(0, 100) + '...' : data.extract) : 'No summary available.';
                                
                                // Distance check for button display
                                let showCollectButton = false;
                                if (userLocationRef.current) {
                                    const userLatLng = L.latLng(userLocationRef.current[0], userLocationRef.current[1]);
                                    const articleLatLng = L.latLng(latlng[0], latlng[1]);
                                    const dist = userLatLng.distanceTo(articleLatLng);
                                    if (dist <= 1000) {
                                        showCollectButton = true;
                                    }
                                }

                                marker.setPopupContent(`
                                    <div class="p-0 overflow-hidden rounded-lg font-sans" style="width: auto; min-width: 220px; max-width: 280px;">
                                        ${imageUrl ? `<div class="w-full h-24 md:h-32 bg-gray-100 bg-cover bg-center" style="background-image: url('${imageUrl}');"></div>` : ''}
                                        <div class="p-3 md:p-4">
                                            <h3 class="font-bold text-gray-900 text-base md:text-lg mb-1 leading-tight">${data.title}</h3>
                                            <p class="text-xs md:text-sm text-gray-600 mb-2 md:mb-3 line-clamp-3">${summary}</p>
                                            <div class="flex items-center justify-between gap-2">
                                                <span class="text-[10px] md:text-xs text-gray-400 flex-grow">Oldest: ${feature.properties.oldest_date || 'N/A'}</span>
                                                
                                                ${showCollectButton ? `
                                                <button onclick="window.collectArticle('${feature.id}')"
                                                   class="inline-flex items-center justify-center px-2 py-1 md:px-3 md:py-1.5 bg-green-50 text-green-600 text-[10px] md:text-xs font-semibold hover:bg-green-100 rounded-md border border-green-600 transition-colors uppercase tracking-wide cursor-pointer">
                                                   <i class="fa-solid fa-star mr-1"></i> Collect
                                                </button>
                                                ` : ''}

                                                <a href="https://en.wikipedia.org/wiki/${title}" 
                                                   target="_blank"
                                                   class="inline-flex items-center justify-center px-2 py-1 md:px-3 md:py-1.5 bg-white text-blue-600 text-[10px] md:text-xs font-semibold hover:bg-blue-50 rounded-md border border-blue-600 transition-colors uppercase tracking-wide">
                                                   Read More
                                                </a>
                                            </div>
                                        </div>
                                    </div>
                                `);
                            } catch (error) {

                                console.error("Error fetching summary:", error);
                                 marker.setPopupContent(`
                                    <div class="p-3">
                                        <p class="text-red-500 text-sm">Failed to load summary.</p>
                                    </div>
                                `);
                            }
                        });
                    }
                }
                return marker;
            };

            const verifyDistances = (currentLocation) => {
                if (!currentLocation || !registryRef.current) return;
                
                const [lat, lon] = currentLocation;
                const center = L.latLng(lat, lon);

                Object.values(registryRef.current).forEach(marker => {
                    // Skip if not a standard marker (e.g. cluster) or if logic differs
                    // Using getLatLng() which works for markers
                     if (marker.getLatLng) {
                        const markerLatLng = marker.getLatLng();
                        const distance = center.distanceTo(markerLatLng); // Meters

                        const icon = marker.options.icon;
                        if (icon && icon.options && icon.options.className) {
                            let originalClass = icon.options.className.replace(' marker-in-range', '');
                            
                            if (distance <= 1000) {
                                // Add highlight class
                                if (!icon.options.className.includes('marker-in-range')) {
                                    marker.getElement()?.classList.add('marker-in-range');
                                    // Also update internal options so it persists on re-render/redraw if leaflet does that
                                    icon.options.className = originalClass + ' marker-in-range';
                                }
                            } else {
                                // Remove highlight class
                                if (icon.options.className.includes('marker-in-range')) {
                                    marker.getElement()?.classList.remove('marker-in-range');
                                    icon.options.className = originalClass;
                                }
                            }
                        }
                    }
                });
            };

            const updateMarkers = (geojson) => {
                if (!markersLayerRef.current) return;
                
                const features = geojson.features || [];
                const seenKeys = new Set();
                
                features.forEach(feature => {
                    let key;
                    const coords = feature.geometry.coordinates; // [lon, lat]
                    
                    if (feature.properties && feature.properties.is_cluster) {
                        key = `cluster_${coords[0]}_${coords[1]}_${feature.properties.count}`;
                    } else if (feature.id) {
                        key = `article_${feature.id}`;
                    } else {
                        // Fallback
                        key = `item_${coords[0]}_${coords[1]}`;
                    }
                    
                    seenKeys.add(key);
                    
                    if (!registryRef.current[key]) {
                        // Create new marker
                        const latlng = [coords[1], coords[0]]; // Leaflet uses [lat, lon]
                        const marker = createMarker(feature, latlng);
                        marker.addTo(markersLayerRef.current);
                        registryRef.current[key] = marker;
                    }
                });
                
                // Cleanup old markers
                Object.keys(registryRef.current).forEach(key => {
                    if (!seenKeys.has(key)) {
                        const marker = registryRef.current[key];
                        markersLayerRef.current.removeLayer(marker);
                        delete registryRef.current[key];
                    }
                });

                // Re-verify distances for all markers (new and old) if we have a location
                if (userLocation) {
                    verifyDistances(userLocation);
                }
            };

            const handleSearchSelect = (article) => {
                if (mapInstanceRef.current && article.geometry && article.geometry.coordinates) {
                    const [lon, lat] = article.geometry.coordinates;
                    mapInstanceRef.current.flyTo([lat, lon], 16, {
                        animate: true,
                        duration: 1.5
                    });
                }
            };

            const handleDateChange = (newRange) => {
                setDateRange(newRange);
                // Trigger fetch with new range
                if (mapInstanceRef.current) {
                    fetchArticles(mapInstanceRef.current.getBounds(), newRange);
                }
            };

            React.useEffect(() => {
                if (!mapRef.current) return;
                
                // Initialize Map
                // Default view: Dublin
                const map = L.map(mapRef.current).setView([53.3498, -6.2606], 13);
                mapInstanceRef.current = map;

                // Define Base Layers
                const streetLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                });

                const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
                });

                // Add default layer
                streetLayer.addTo(map);

                // Add Layer Control
                const baseMaps = {
                    "Street View": streetLayer,
                    "Satellite": satelliteLayer
                };
                L.control.layers(baseMaps, null, { position: 'topright' }).addTo(map);

                // Initialize Markers Layer Group (Standard Layer, not MarkerCluster anymore for server-side clusters)
                const markersLayer = L.layerGroup().addTo(map);
                markersLayerRef.current = markersLayer;
                
                // Initial fetch
                fetchArticles(map.getBounds(), [1000, 2024]);

                // Cleanup
                return () => {
                    map.remove();
                };
            }, []);

            // Ref to store current date range for event listeners
            const dateRangeRef = React.useRef(dateRange);
            React.useEffect(() => {
                dateRangeRef.current = dateRange;
            }, [dateRange]);

            // User Location Handler
            const handleLocate = () => {
                return new Promise((resolve, reject) => {
                    if (!navigator.geolocation) {
                        alert("Geolocation is not supported by your browser.");
                        resolve();
                        return;
                    }

                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const { latitude, longitude } = position.coords;
                            const latlng = [latitude, longitude];
                            
                            setUserLocation(latlng);

                            if (mapInstanceRef.current) {
                                mapInstanceRef.current.flyTo(latlng, 15, {
                                    animate: true,
                                    duration: 1.5
                                });
                            }
                            resolve();
                        },
                        (error) => {
                            console.error("Geolocation error:", error);
                            let msg = "Unable to retrieve your location.";
                            if (error.code === 1) msg = "Location permission denied.";
                            else if (error.code === 2) msg = "Location unavailable.";
                            else if (error.code === 3) msg = "Location request timed out.";
                            
                            alert(msg);
                            resolve();
                        }, 
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0
                        }
                    );
                });
            };

            // Effect to render user location marker and radius circle
            React.useEffect(() => {
                if (!mapInstanceRef.current || !userLocation) return;
                
                // Initialize layer if needed
                if (!userLocationLayerRef.current) {
                    userLocationLayerRef.current = L.layerGroup().addTo(mapInstanceRef.current);
                }
                
                // Draw/Update Circle
                if (!userCircleRef.current) {
                    userCircleRef.current = L.circle(userLocation, {
                        radius: 1000, // 1km
                        color: '#3b82f6', // blue-500
                        fillColor: '#3b82f6',
                        fillOpacity: 0.1,
                        weight: 1,
                        dashArray: '5, 5' // Dashed line styling
                    }).addTo(mapInstanceRef.current);
                } else {
                    userCircleRef.current.setLatLng(userLocation);
                }

                const layer = userLocationLayerRef.current;
                layer.clearLayers();

                // Create a pulsing dot marker
                const pulsingIcon = L.divIcon({
                    className: 'css-icon',
                    html: '<div class="w-4 h-4 bg-blue-600 rounded-full border-2 border-white shadow-lg relative"><div class="absolute inset-0 bg-blue-500 rounded-full animate-ping opacity-75"></div></div>',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });

                L.marker(userLocation, {
                    icon: pulsingIcon,
                    zIndexOffset: 1000 // Ensure it's on top
                }).addTo(layer)
                  .bindPopup("You are here", { autoClose: false, closeButton: false } )
                  .openPopup();

                // Trigger verification
                verifyDistances(userLocation);

            }, [userLocation]);

            // Assign global handler that uses current state
            React.useEffect(() => {
                window.collectArticle = async (articleId) => {
                    const currentLocation = userLocationRef.current;
                    if (!currentLocation) {
                        stableAddToast("You need to locate yourself first!", 'error');
                        return;
                    }

                    // Get CSRF token
                    const getCookie = (name) => {
                        let cookieValue = null;
                        if (document.cookie && document.cookie !== '') {
                            const cookies = document.cookie.split(';');
                            for (let i = 0; i < cookies.length; i++) {
                                const cookie = cookies[i].trim();
                                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                                    break;
                                }
                            }
                        }
                        return cookieValue;
                    };
                    const csrftoken = getCookie('csrftoken');

                    try {
                        const response = await fetch('/api/collect/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrftoken
                            },
                            body: JSON.stringify({
                                article_id: articleId,
                                lat: currentLocation[0], // Latitude
                                lon: currentLocation[1]  // Longitude
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (response.ok) {
                             if (data.message === 'Already collected!') {
                                stableAddToast(data.message, 'info');
                            } else {
                                stableAddToast(data.message.replace('Success! ', ''), 'success');
                            }
                        } else if (response.status === 403) {
                             stableAddToast(data.error || "Authentication required or too far away.", 'error');
                             if (data.detail === "Authentication credentials were not provided.") {
                                 setTimeout(() => window.location.href = "/accounts/login/", 2000);
                             }
                        } else {
                            stableAddToast(data.error || "Something went wrong.", 'error');
                        }
                    } catch (error) {
                        console.error("Collect failed:", error);
                        stableAddToast("Failed to collect article. Check network.", 'error');
                    }
                };
            }, [stableAddToast]);

            // Separate effect for moveend listener to avoid re-initializing map
            React.useEffect(() => {
                if (!mapInstanceRef.current) return;
                
                const onMoveEnd = () => {
                    fetchArticles(mapInstanceRef.current.getBounds(), dateRangeRef.current);
                };
                
                mapInstanceRef.current.on('moveend', onMoveEnd);
                
                return () => {
                    mapInstanceRef.current.off('moveend', onMoveEnd);
                };
            }, []);

            // Auto-locate on load
            React.useEffect(() => {
                handleLocate();
            }, []);

            return (
                <div className="w-full h-full relative">
                    <div ref={mapRef} id="map-container" className="rounded-lg shadow-inner" />
                    
                    <SearchBar onSelect={handleSearchSelect} />
                    <LocationControl onLocate={handleLocate} />
                    <ToastContainer toasts={toasts} removeToast={removeToast} />

                    <TimelineControl 
                        minDate={1000} 
                        maxDate={2024} 
                        currentRange={dateRange} 
                        onChange={handleDateChange} 
                    />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('map-root'));
        root.render(<WikiMap />);


    </script>
{% endblock %}
